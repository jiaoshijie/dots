set nocompatible  " no vi compatible

set modelines=0
set nomodeline

let mapleader=' '
let maplocalleader=','

noremap <C-j> <C-[>
inoremap <C-j> <C-[>
" do nothing(normal visual select operator-wait)
nnoremap s <Nop>
nnoremap S <Nop>
nnoremap C <Nop>
" only use <C-u> and <C-d>
nnoremap <C-f> <Nop>
nnoremap <C-b> <Nop>
nnoremap <Space> <Nop>
vnoremap <Space> <Nop>
nnoremap <leader><leader> <C-^>
nnoremap <silent> <C-l> :nohl<cr><C-l>
nnoremap <leader>/ /\<\><left><left>
nnoremap <silent> Q q:
nnoremap Y y$
nnoremap <silent> <leader>ps :setlocal spell! spelllang=en_us<CR>
vnoremap J :m '>+1<CR>gv=gv
vnoremap K :m '<-2<CR>gv=gv
command! SudoWrite execute 'write !sudo tee % >/dev/null' <bar> edit!

" Disable all other language support for plugins
let g:loaded_python_provider=0
let g:loaded_perl_provider=0
let g:loaded_node_provider=0
let g:loaded_ruby_provider=0
let g:loaded_python3_provider=0
" NOTE: netrw
let g:netrw_banner       = 0  " disable annoying banner
let g:netrw_browse_split = 0  " open in prior window
let g:netrw_liststyle    = 0  " tree view
let g:netrw_keepdir      = 1
let g:netrw_hide         = 1
let g:netrw_list_hide    = '\(^\|\s\s\)\zs\.\S\+'

filetype plugin indent on
syntax on

set mouse=nvi
set bs=indent,eol,start  " control the behavior of <BS> <CTRL-H> <CTRL-W> <CTRL-U>
set nowrap
set clipboard=
set nrformats= " For <C-a> and <C-x>
set hidden     " allow to switch buffer even the current buffer is unsaved
set confirm    " friendly quit for when quitting the buffer is not saved
set showcmd    " show the normal mode key sequence in cmd
set timeout
set ttimeout
set ttimeoutlen=50  " if not set <ESC> will wait timeoutlen time
set path+=**  " expand the search dir for `gf` `:find` etc
set lazyredraw  " when execute macros, only draw the window when the macro has been finished
set fo-=t
set fo-=c
set shortmess-=S
set cursorline
set scrolloff=6
set laststatus=2
set splitright
set splitbelow
set fileencodings=ucs-bom,utf-8,cp936,default,latin1  " NOTE: cp936 is a superset of gbk
set wildignore=*.o,*.a,*.so,tags
set nobackup
set noswapfile
set wildmenu  " for cmd mode completion
set completeopt=menuone  " For more details ":h ins-completion", ":h 'complete'"
set dictionary=/usr/share/dict/words
set complete=.,w,b
set pumheight=15
" NOTE: indent
set autoindent
set smartindent
set shiftwidth=4  " set the indent width
set tabstop=4     " A single <tab> character '\t' should take how many normal character length
set expandtab     " When press <tab> instert space instead
set softtabstop=4 " When expandtab is on, how many space a tab should represent
set smarttab      " When on, a <tab> press in the begin of the line is base on `shiftwidth`, not `tabstop` or `softtabstop`
set shiftround    " for `<<` and `>>` in normal mode
" NOTE: search
set ignorecase
set smartcase
set hlsearch
set incsearch

set statusline+=%<%f\ %*%m%h%r%*\ %=\ %*%(%p%%\ %v:%l/%L%)%*

augroup JSJ_recover_cursor_pos
  autocmd!
  autocmd BufReadPost * if line("'\"") > 1 && line("'\"") <= line("$") | exe 'normal! g`"' | endif
augroup END

function! s:error_msg(message)
  echohl ErrorMsg
  echom a:message
  echohl NONE
  return 0
endfunction

function! JSJ_clear_trailing_space_and_lines()
    let l = line(".")
    let c = col(".")
    %s/\s\+$//ge
    %s/\(\n\)\+\%$//ge
    call cursor(l, c)
endfunction
nnoremap <silent> <leader>fc :call JSJ_clear_trailing_space_and_lines()<cr>

function! JSJ_inspect_highlight_group()
  let l:synid = synID(line('.'), col('.'), 1)
  let l:synname = [ synIDattr(l:synid, 'name') ]
  while 1
    let l:synid = synIDtrans(l:synid)
    let l:temp = synIDattr(l:synid, 'name')
    if synname[-1] ==# l:temp
      break
    endif
    let l:synname = add(l:synname, l:temp)
  endwhile
  echo l:synname
endfunction
command! -nargs=0 Inspect call JSJ_inspect_highlight_group()

" copy register 0 content to system clipboard for X11 if doesn't have clipboard support
function! JSJ_write2clipboard()
  if executable('xsel')
    let l:command = "xsel -ib"
  elseif executable('xclip')
    let l:command = "xclip"
  else
    call s:error_msg("no X11 clipboard program(xsel or xclip) available!!!")
    return
  endif
  call system(l:command, @0)
endfunction
command! -nargs=0 Cc call JSJ_write2clipboard()

if executable('rg')
  set grepprg=rg\ --vimgrep\ -S
  set grepformat=%f:%l:%c:%m
else
  set grepprg=grep\ -rIHn
endif

runtime ftplugin/man.vim

" ------------------------------------ 703 ------------------------------------
if v:version < 703
  finish
endif

set colorcolumn=79
silent! call mkdir(expand('/tmp/jsj_vim_u/undodir'), 'p', 0700)
set undodir=/tmp/jsj_vim_u/undodir//
set undofile

" NOTE: fzf (Fuzzy Finder)
if isdirectory('/usr/share/vim/vimfiles')  " arch linux
  set rtp+=/usr/share/vim/vimfiles
endif
if isdirectory('/usr/share/doc/fzf/examples/')  " ubuntu linux
  set rtp+=/usr/share/doc/fzf/examples/
endif

function! s:get_git_root()
  let l:root = split(system('git rev-parse --show-toplevel'), '\n')[0]
  return v:shell_error ? '' : l:root
endfunction

function! JSJ_fzf_git_files()
  if exists('g:loaded_fzf')
    let l:root = s:get_git_root()
    if empty(l:root)
        return s:error_msg('Not in git repo!!!')
    else
        let l:source = 'git ls-files --others --exclude-standard --cached | uniq'
        let l:prompt = '"GitFiles> "'
    endif

    return fzf#run(fzf#wrap('gfiles', {
    \ 'source':  l:source,
    \ 'dir':     l:root,
    \ 'options': '-m --prompt ' . l:prompt
    \}, 0))
  else
    return s:error_msg("`fzf` is not installed!!!")
  endif
endfunction
nnoremap <silent> <C-p> :call JSJ_fzf_git_files()<cr>

" ------------------------------------ 704 ------------------------------------
if v:version < 704 || v:version == 704 && has("patch1799") == 0
  finish
endif

set shortmess+=c
set completeopt+=noselect
set statusline=
set noshowmode
set list
set listchars=trail:Â·,tab:Â»\ ,extends:â€¦,precedes:â€¦
set t_8f=[38;2;%lu;%lu;%lum        " set foreground color
set t_8b=[48;2;%lu;%lu;%lum        " set background color
set termguicolors
let &t_SI.="\e[5 q" "SI(start insert)
let &t_SR.="\e[4 q" "SR(start replace)
let &t_EI.="\e[1 q" "EI(end insert/replace)

function! s:statusline_hl_group()
  hi StatusLine cterm=NONE gui=NONE guifg=#ffffff guibg=#2c323c
  hi StatusLineNC cterm=NONE gui=NONE guifg=#000000 guibg=#5c6370
  hi! link StatusLineTerm StatusLine
  hi! link StatusLineTermNC StatusLineNC
  hi Statusline_mode cterm=bold gui=bold guifg=#282c34 guibg=#98c379
  hi Statusline_file cterm=NONE gui=NONE guifg=#e5c07b guibg=#2c323c
  hi Statusline_wran cterm=NONE gui=NONE guifg=#e5c07b guibg=#e06c75
  hi Statusline_sep  cterm=NONE gui=NONE guibg=#2c323c
  hi Statusline_type cterm=NONE gui=NONE guifg=#e5c07b guibg=#2c323c
  hi Statusline_enc  cterm=NONE gui=NONE guifg=#d19a66 guibg=#3e4452
endfunction

function! JSJ_mode_info()
  if (mode() =~# '\v(v|V|)')
    exe 'hi Statusline_mode guibg=#c678dd'
    return { 'v': 'VISUAL', 'V': 'VÂ·Line', '': 'VÂ·Block' }[mode()]
  elseif (mode() =~# 'i')
    exe 'hi Statusline_mode guibg=#61afef'
    return "INSERT"
  elseif (mode() =~# 'R')
    exe 'hi Statusline_mode guibg=#e06c75'
    return "REPLACE"
  elseif (mode() =~# '\v(c|t)')
    exe 'hi Statusline_mode guibg=#56B6C2'
    return { 't': 'TERMINAL', 'c': 'COMMAND' }[mode()]
  else
    exe 'hi Statusline_mode guibg=#98c379'
  endif
  return "NORMAL"
endfunction

function! s:statusline_style(active) abort
  setlocal statusline=
  if a:active == 0
    setlocal statusline+=\ %<%f\ %*  " full file path
    setlocal statusline+=%#Statusline_wran#%m%h%r%*  " modify,help tag,readonly
    setlocal statusline+=\ %=\ %*  " Separation
    setlocal statusline+=%(%v:%l/%L%)\ %*  " file position information
  else
    setlocal statusline+=%#Statusline_mode#\ %{JSJ_mode_info()}\ %*  " mode(NORMAL,INSERT,etc)
    setlocal statusline+=%#Statusline_file#\ %<%t\ %*  " only file name
    setlocal statusline+=%#Statusline_wran#%m%h%r%*  " modify,help tag,readonly
    setlocal statusline+=%#Statusline_sep#\ %=\ %*  " Separation
    setlocal statusline+=%#Statusline_type#%{&ft}\ %*  " filetype
    setlocal statusline+=%#Statusline_enc#\ %{&fenc!=''?&fenc:&enc}\[%{&ff}\]\ %*  " encode, fileformat
    setlocal statusline+=%#Statusline_mode#\ %p%%\ %v:%l/%L\ %*  " file position information
  endif
endfunction

augroup jsj_Statusline
  autocmd!
  autocmd ColorScheme * call s:statusline_hl_group()
  autocmd VimEnter,BufEnter,WinEnter * :call s:statusline_style(1)
  autocmd WinLeave * :call s:statusline_style(0)
augroup end

set background=dark
try
  colorscheme jsj
catch /^Vim\%((\a\+)\)\=:E185/
  colorscheme default
  set background=dark  " set dark again
  hi CursorLine cterm=NONE gui=NONE
  hi Pmenu cterm=NONE gui=NONE guifg=#ebdbb2 guibg=#504945
  hi PmenuSel cterm=bold gui=bold guifg=#504945 guibg=#83a598
  hi! link ColorColumn CursorLine
endtry

" ------------------------------------ 801 ------------------------------------
if v:version < 801
    finish
endif

tnoremap <Esc> <c-\><c-n>

" ------------------------------------ 802 ------------------------------------
if v:version < 802
    finish
endif

set diffopt=vertical,filler,context:3,foldcolumn:1,internal,algorithm:histogram,indent-heuristic
set switchbuf=uselast

function! s:highlight_yanked_text()
  if v:event.operator isnot 'y'
    return
  endif
  if v:event.visual == v:true
    let l:pattern = '\v%\V'
  else
    let l:pos = [line("'["), col("'["), line("']"), col("']")]
    if l:pos[0] == l:pos[2]
      let l:pattern = printf('\v%%%dl%%%dc\_.{%d}', l:pos[0], l:pos[1], strchars(v:event.regcontents[0]))
    else
      let l:pattern = printf('\v%%%dl%%%dc\_.{-}%%%dl%%%dc.=', l:pos[0], l:pos[1], l:pos[2], l:pos[3])
    endif
  endif
  let l:winid = win_getid()
  let l:id = matchadd('IncSearch', l:pattern, 11)
  call timer_start(300, {-> matchdelete(l:id, l:winid)})
endfunction

augroup JSJ_highlight_yanked_text
  autocmd!
  autocmd TextYankPost * call s:highlight_yanked_text()
augroup END

" ------------------------------------ 900 ------------------------------------
if v:version < 900
    finish
endif

set wildoptions=pum
silent! packadd! comment
